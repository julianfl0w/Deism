<!DOCTYPE html>
<html>
  <head>
    <title>Book of Julian Sunburst</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@500&display=swap" rel="stylesheet">
    <style>
      #chart {
        width: 100%;
        height: 100vh;
        margin-bottom: 100px;
      }

      #selected-node-text {
        width: 100%;
        height: 100vh;
        overflow: auto;
      }

      .flex-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
      }
      .angled-text {
        font-family: 'Raleway', sans-serif; /* Using Raleway */
        font-weight: 500; /* Medium weight */
      }


      @media (orientation: landscape) {
        .flex-container {
          flex-direction: row;
          overflow: hidden;
        }
        #chart {
          margin-bottom: 0px;
          margin-right: 100px;
        }
      }
    </style>
  </head>
  <body>
    <div class="flex-container">
      <div id="chart"></div>
      <div id="selected-node-text"></div>
    </div>
    <script>
      // Load the Flare data from the local JSON file
      fetch("julian_flare.json")
        .then((response) => response.json())
        .then((data) => {
          // Define the chart function
          function createSunburst(data) {
            // Specify the chart’s dimensions.
            const width = 928;
            const height = width;
            const radius = width / 6;

            // Create the color scale.
            const color = d3.scaleOrdinal(
              d3.quantize(d3.interpolateRainbow, data.children.length + 1)
            );

            // Compute the layout.
            const hierarchy = d3
              .hierarchy(data)
              .sum((d) => d.value)
              .sort((a, b) => b.value - a.value);
            const root = d3
              .partition()
              .size([2 * Math.PI, hierarchy.height + 1])(hierarchy);
            root.each((d) => (d.current = d));

            // Create the arc generator.
            const arc = d3
              .arc()
              .startAngle((d) => Math.max(0, Math.min(2 * Math.PI, d.x0)))
              .endAngle((d) => Math.max(0, Math.min(2 * Math.PI, d.x1)))
              .padAngle((d) => Math.min((d.x1 - d.x0) / 2, 0.005))
              .padRadius(radius * 1.5)
              .innerRadius((d) => Math.max(0, d.y0 * radius))
              .outerRadius((d) => Math.max(0, d.y1 * radius - 1));

            // Create the SVG container.
            const svg = d3
              .create("svg")
              .attr("viewBox", [-width / 2, -height / 2, width, width])
              .style("font-family", "'Raleway', sans-serif") // Apply the Raleway font
              .style("font", "14px sans-serif"); // Set the font size to 14 pixels.

            // Create root label here without text
            const rootLabel = svg
              .append("text")
              .attr("text-anchor", "middle")
              .style("font-size", "22px")
              .style("font-weight", "bold")
              .style("font-family", "'Raleway', sans-serif") // Apply the Raleway font
              .attr("y", 0); // adjust position as needed

            rootLabel.text(data.name); // root name

            // Append the arcs.
            const path = svg
              .append("g")
              .selectAll("path")
              .data(root.descendants())
              .join("path")
              .attr("fill", (d) => {
                while (d.depth > 1) d = d.parent;
                return color(d.data.name);
              })
              .attr("fill-opacity", (d) =>
                arcVisible(d.current) ? (d.children ? 0.6 : 0.4) : 0
              )
              .attr("pointer-events", (d) =>
                arcVisible(d.current) ? "auto" : "none"
              )
              .attr("d", (d) => arc(d.current));

            // Make them clickable
            path.style("cursor", "pointer").on("click", clicked);
            //.filter((d) => d.children)

            const format = d3.format(",d");
            path.append("title").text(
              (d) =>
                `${d
                  .ancestors()
                  .map((d) => d.data.name)
                  .reverse()
                  .join("/")}\n${format(d.value)}`
            );
            const label = svg
              .append("g")
              .attr("pointer-events", "none")
              .attr("text-anchor", "middle")
              .style("user-select", "none")
              .selectAll("text")
              .data(root.descendants().slice(1))
              .join("text")
              .attr("dy", "0.35em")
              .attr("fill-opacity", (d) => +labelVisible(d.current))
              .attr("transform", (d) => labelTransform(d.current))
              .text((d) => d.data.name)              
              .style("font-size", ((d) => d.depth === 1 ? "20px" : "12px"))
              .style("font-weight", ((d) => d.depth === 1 ? "bold" : "bold"))
              .style("text-shadow", "1px 1px 8px rgba(255, 255, 255, 1)") // Apply white text shadow with raised opacity
              .style("font-family", "'Raleway', sans-serif"); // Apply the Raleway font

            const parent = svg
              .append("circle")
              .datum(root)
              .attr("r", radius)
              .attr("fill", "none")
              .attr("pointer-events", "all")
              .on("click", clicked);

            // Handle zoom on click.
            function clicked(event, p) {
              rootLabel = document.getElementById("root-label-id"); // Replace with the actual ID
              rootLabel.className = "angled-text"; // Apply the class
              rootLabel.text(p.data.name); // update the root label to the new root name
              parent.datum(p.parent || root);

              // display its text in the dedicated HTML element.
              var selectedNodeTextElement = document.getElementById("selected-node-text");
              selectedNodeTextElement.innerHTML = p.data.text;
              selectedNodeTextElement.className = "angled-text"; // Apply the class

              root.each(
                (d) =>
                  (d.target = {
                    x0:
                      Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) *
                      2 *
                      Math.PI,
                    x1:
                      Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) *
                      2 *
                      Math.PI,
                    y0: Math.max(0, d.y0 - p.depth),
                    y1: Math.max(0, d.y1 - p.depth),
                  })
              );

              const t = svg.transition().duration(750);

              // Transition the data on all arcs, even the ones that aren’t visible,
              // so that if this transition is interrupted, entering arcs will start
              // the next transition from the desired position.
              path
                .transition(t)
                .tween("data", (d) => {
                  const i = d3.interpolate(d.current, d.target);
                  return (t) => (d.current = i(t));
                })
                .filter(function (d) {
                  return (
                    +this.getAttribute("fill-opacity") || arcVisible(d.target)
                  );
                })
                .attr("fill-opacity", (d) =>
                  arcVisible(d.target) ? (d.children ? 0.6 : 0.4) : 0
                )
                .attr("pointer-events", (d) =>
                  arcVisible(d.target) ? "auto" : "none"
                )
                .attrTween("d", (d) => () => arc(d.current));

              label
                .filter(function (d) {
                  return (
                    +this.getAttribute("fill-opacity") || labelVisible(d.target)
                  );
                })
                .transition(t)
                .attr("fill-opacity", (d) => +labelVisible(d.target))
                .attrTween("transform", (d) => () => labelTransform(d.current));
            }

            function arcVisible(d) {
              return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0;
            }

            function labelVisible(d) {
              return (
                d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03
              );
            }

            function labelTransform(d) {
              const x = (((d.x0 + d.x1) / 2) * 180) / Math.PI;
              const y = ((d.y0 + d.y1) / 2) * radius;
              return `rotate(${x - 90}) translate(${y},0) rotate(${
                x < 180 ? 0 : 180
              })`;
            }

            return svg.node();
          }

          // Call the function to create the icicle chart and append it to the DOM
          const chartContainer = document.getElementById("chart");
          chartContainer.appendChild(createSunburst(data));

          // Set the initial text content to the root node's text
          const textContainer = document.getElementById("selected-node-text");
          textContainer.innerHTML = data.text;
        })
        .catch((error) => {
          console.error("Error loading JSON:", error);
        });
    </script>
  </body>
</html>
